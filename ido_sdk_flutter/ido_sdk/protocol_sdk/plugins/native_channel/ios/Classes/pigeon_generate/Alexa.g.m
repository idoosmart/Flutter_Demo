// Autogenerated from Pigeon (v11.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import "Alexa.g.h"

#if TARGET_OS_OSX
#import <FlutterMacOS/FlutterMacOS.h>
#else
#import <Flutter/Flutter.h>
#endif

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSArray *wrapResult(id result, FlutterError *error) {
  if (error) {
    return @[
      error.code ?: [NSNull null], error.message ?: [NSNull null], error.details ?: [NSNull null]
    ];
  }
  return @[ result ?: [NSNull null] ];
}
static id GetNullableObjectAtIndex(NSArray *array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}

@interface ApiAlexaError ()
+ (ApiAlexaError *)fromList:(NSArray *)list;
+ (nullable ApiAlexaError *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@implementation ApiAlexaError
+ (instancetype)makeWithErrorCode:(nullable NSNumber *)errorCode
    errorMessage:(nullable NSString *)errorMessage
    extData:(nullable NSDictionary<NSString *, NSString *> *)extData {
  ApiAlexaError* pigeonResult = [[ApiAlexaError alloc] init];
  pigeonResult.errorCode = errorCode;
  pigeonResult.errorMessage = errorMessage;
  pigeonResult.extData = extData;
  return pigeonResult;
}
+ (ApiAlexaError *)fromList:(NSArray *)list {
  ApiAlexaError *pigeonResult = [[ApiAlexaError alloc] init];
  pigeonResult.errorCode = GetNullableObjectAtIndex(list, 0);
  pigeonResult.errorMessage = GetNullableObjectAtIndex(list, 1);
  pigeonResult.extData = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable ApiAlexaError *)nullableFromList:(NSArray *)list {
  return (list) ? [ApiAlexaError fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.errorCode ?: [NSNull null]),
    (self.errorMessage ?: [NSNull null]),
    (self.extData ?: [NSNull null]),
  ];
}
@end

NSObject<FlutterMessageCodec> *ApiAlexaHostGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void ApiAlexaHostSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<ApiAlexaHost> *api) {
  /// token 变更，空为退出状态
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.native_channel.ApiAlexaHost.onTokenChanged"
        binaryMessenger:binaryMessenger
        codec:ApiAlexaHostGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(onTokenChangedToken:error:)], @"ApiAlexaHost api (%@) doesn't respond to @selector(onTokenChangedToken:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_token = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api onTokenChangedToken:arg_token error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// 创建下行流
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.native_channel.ApiAlexaHost.createDownStream"
        binaryMessenger:binaryMessenger
        codec:ApiAlexaHostGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(createDownStreamUrl:completion:)], @"ApiAlexaHost api (%@) doesn't respond to @selector(createDownStreamUrl:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_url = GetNullableObjectAtIndex(args, 0);
        [api createDownStreamUrl:arg_url completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// 关闭下行流
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.native_channel.ApiAlexaHost.closeDownStream"
        binaryMessenger:binaryMessenger
        codec:ApiAlexaHostGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(closeDownStreamWithCompletion:)], @"ApiAlexaHost api (%@) doesn't respond to @selector(closeDownStreamWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api closeDownStreamWithCompletion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// 创建上行流 注：流数据由 askAudioData(Uint8List data, bool isEnd) 提供
  /// url 请求地址
  /// jsonBody 参数
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.native_channel.ApiAlexaHost.createUploadStream"
        binaryMessenger:binaryMessenger
        codec:ApiAlexaHostGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(createUploadStreamUrl:jsonBody:completion:)], @"ApiAlexaHost api (%@) doesn't respond to @selector(createUploadStreamUrl:jsonBody:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_url = GetNullableObjectAtIndex(args, 0);
        FlutterStandardTypedData *arg_jsonBody = GetNullableObjectAtIndex(args, 1);
        [api createUploadStreamUrl:arg_url jsonBody:arg_jsonBody completion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// 关闭上行流
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.native_channel.ApiAlexaHost.closeUploadStream"
        binaryMessenger:binaryMessenger
        codec:ApiAlexaHostGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(closeUploadStreamWithCompletion:)], @"ApiAlexaHost api (%@) doesn't respond to @selector(closeUploadStreamWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api closeUploadStreamWithCompletion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// ask 音频流数据（由设备采集）
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.native_channel.ApiAlexaHost.askAudioData"
        binaryMessenger:binaryMessenger
        codec:ApiAlexaHostGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(askAudioDataData:isEnd:error:)], @"ApiAlexaHost api (%@) doesn't respond to @selector(askAudioDataData:isEnd:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        FlutterStandardTypedData *arg_data = GetNullableObjectAtIndex(args, 0);
        NSNumber *arg_isEnd = GetNullableObjectAtIndex(args, 1);
        FlutterError *error;
        [api askAudioDataData:arg_data isEnd:arg_isEnd error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface ApiAlexaFlutterCodecReader : FlutterStandardReader
@end
@implementation ApiAlexaFlutterCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [ApiAlexaError fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface ApiAlexaFlutterCodecWriter : FlutterStandardWriter
@end
@implementation ApiAlexaFlutterCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[ApiAlexaError class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface ApiAlexaFlutterCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation ApiAlexaFlutterCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[ApiAlexaFlutterCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[ApiAlexaFlutterCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *ApiAlexaFlutterGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    ApiAlexaFlutterCodecReaderWriter *readerWriter = [[ApiAlexaFlutterCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

@interface ApiAlexaFlutter ()
@property(nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation ApiAlexaFlutter

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)replyAudioDataMessageId:(NSString *)arg_messageId data:(FlutterStandardTypedData *)arg_data isEnd:(NSNumber *)arg_isEnd completion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.native_channel.ApiAlexaFlutter.replyAudioData"
      binaryMessenger:self.binaryMessenger
      codec:ApiAlexaFlutterGetCodec()];
  [channel sendMessage:@[arg_messageId ?: [NSNull null], arg_data ?: [NSNull null], arg_isEnd ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)onUploadStreamErrorError:(ApiAlexaError *)arg_error completion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.native_channel.ApiAlexaFlutter.onUploadStreamError"
      binaryMessenger:self.binaryMessenger
      codec:ApiAlexaFlutterGetCodec()];
  [channel sendMessage:@[arg_error ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)downStreamDataData:(FlutterStandardTypedData *)arg_data completion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.native_channel.ApiAlexaFlutter.downStreamData"
      binaryMessenger:self.binaryMessenger
      codec:ApiAlexaFlutterGetCodec()];
  [channel sendMessage:@[arg_data ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)onDownStreamErrorError:(ApiAlexaError *)arg_error completion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.native_channel.ApiAlexaFlutter.onDownStreamError"
      binaryMessenger:self.binaryMessenger
      codec:ApiAlexaFlutterGetCodec()];
  [channel sendMessage:@[arg_error ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)logLogMsg:(NSString *)arg_logMsg completion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.native_channel.ApiAlexaFlutter.log"
      binaryMessenger:self.binaryMessenger
      codec:ApiAlexaFlutterGetCodec()];
  [channel sendMessage:@[arg_logMsg ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end

